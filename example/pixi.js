
var PIXI 	      = require( 'pixi.js' );
var ArcTextures   = require( '../ArcTextures' );
var TexturePacker = require( 'texture-packer' );


window.onload = function(){

	var resolution = 2;
	var stageSize = 600;
	var renderer = PIXI.autoDetectRenderer( stageSize,stageSize, {
		resolution: resolution,
		backgroundColor: 0x222222
	});

	var stage = new PIXI.Container();
	//stage.scale.set( 0.5 );
	stage.position.x = stageSize / 2;
	stage.position.y = stageSize / 2;

	document.body.appendChild( renderer.view );
	document.body.style.backgroundColor = '#000';
	renderer.view.style.width = ( renderer.view.width / resolution ) + 'px';
	renderer.view.style.height = ( renderer.view.height / resolution ) + 'px';

	var start = 60;
	var count = 6;
	var span  = 20;
	var thick = 18;
	var trim  = true;

	var radii = [];
	for( var i = 0; i<count; i++ ){
		radii.push( ( i * span ) + start );
	}

	var arcTextures = [];
	var entry,arcTexture;

	var packer = new TexturePacker();
	var baseTexture = PIXI.BaseTexture.fromCanvas( packer.canvas );
	baseTexture.resolution = resolution;
	// render multiple arc textures of different radii

	for( var i = 0; i<radii.length; i++ ){

		arcTexture = new ArcTextures({
			radius: radii[i],
			thickness: thick,
			resolution: resolution,
			trim: trim,

			color: '#ffffff',
			debug: false,
			debugAlpha: 0.2,
			debugColor: '#0000ff'

		});

		arcTexture.generate( function( canvas ){

			// create a texture using our baseTexture generated by the texture packer
			// uvs are generated below.
			var texture = new PIXI.Texture( baseTexture );
			// add the arc canvas to the texture packer
			packer.add( canvas, texture );

			return texture;
		});

		entry = {
			radius: radii[i],
			arcs: arcTexture,
			container: new PIXI.Container,
			pool: [],
			start: ( Math.PI * 2 ) * Math.random()
		};

		stage.addChild( entry.container );

		arcTextures.push( entry );

	}

	packer.pack();
	baseTexture.update();

	packer.forEach( function( source, texture, packed ){

		texture.frame.x = packed.x / resolution;
		texture.frame.y = packed.y / resolution;
		texture.frame.width = packed.width / resolution;
		texture.frame.height = packed.height / resolution;

		texture._updateUvs();

	} );

	document.body.appendChild( packer.canvas );

	var getPooled = function( pool, idx, texture ){
		var sprite;
		if( idx >= pool.length ){
			sprite = new PIXI.Sprite( texture );

			if( trim ){
				sprite.anchor.set( 1,0 );
			}else{
				sprite.anchor.set( 0,0 );
			}

			pool.push( sprite );
		}else{
			sprite = pool[idx];
			sprite.texture = texture;
		}

		return sprite;
	};

	var radians = 0;

	var rad360 = Math.PI * 2;
	var toRadians = Math.PI / 180;

	var render = function(){

		radians += toRadians * 0.5;

		for( var i = 0; i<arcTextures.length; i++ ){

			var lastIdx = -1;
			var entry = arcTextures[i];
			var pool = entry.pool;
			var rad = ( radians + entry.start ) % rad360;

			entry.arcs.drawRadians( rad , function( idx, radians, texture ){

				var sprite = getPooled( pool, idx, texture );
				if( !sprite.parent ) {
					entry.container.addChild( sprite );
				}

				if( trim ){
					sprite.position.set(
						Math.cos( radians ) * entry.radius,
						Math.sin( radians ) * entry.radius
					);
					sprite.rotation = radians;
				}else{
					sprite.position.set( 0,0 );
					sprite.rotation = radians;
				}

				lastIdx = idx;
			});

			for( var j = lastIdx+1; j<pool.length; j++ ){
				if( pool[j].parent ){
					entry.container.removeChild( pool[j] );
				}
			}

		}


		renderer.render( stage );
		requestAnimationFrame( render );

	};

	render();

};
