
var PIXI 	      = require( 'pixi.js' );
var ArcSprites 	  = require( '../ArcSprites' );
var TexturePacker = require( 'texture-packer' );


window.onload = function(){

	var resolution = 2;
	var stageSize = 600;
	var renderer = PIXI.autoDetectRenderer( stageSize,stageSize, {
		resolution: resolution,
		backgroundColor: 0x222222
	});

	var stage = new PIXI.Container();
	stage.position.x = stageSize / 2;
	stage.position.y = stageSize / 2;

	document.body.appendChild( renderer.view );
	document.body.style.backgroundColor = '#000';
	renderer.view.style.width = ( renderer.view.width / resolution ) + 'px';
	renderer.view.style.height = ( renderer.view.height / resolution ) + 'px';

	var start = 40;
	var count = 10;
	var span = 30;

	var radii = [];
	for( var i = 0; i<count; i++ ){
		radii.push( ( i * span ) + start );
	}

	var arcSprites = [];
	var entry,arcSprite;

	var packer = new TexturePacker();
	var baseTexture = PIXI.BaseTexture.fromCanvas( packer.canvas );
	baseTexture.resolution = resolution;
	// render multiple arc sprites of different radii

	for( var i = 0; i<radii.length; i++ ){

		arcSprite = new ArcSprites({
			radius: radii[i],
			thickness: span * 0.45,
			resolution: resolution,
			debug: true,
			color: '#ffffff'
		});

		arcSprite.generate( function( canvas ){

			// create a texture using our baseTexture generated by the texture packer
			// uvs are generated below.
			var texture = new PIXI.Texture( baseTexture );
			// add the arc canvas to the texture packer
			packer.add( canvas, texture );

			return texture;
		});

		entry = {
			radius: radii[i],
			arcs: arcSprite,
			container: new PIXI.Container,
			pool: [],
			start: ( Math.PI * 2 ) * Math.random()
		};

		stage.addChild( entry.container );

		arcSprites.push( entry );

	}

	packer.pack();
	baseTexture.update();

	packer.forEach( function( source, texture, packed ){

		texture.frame.x = packed.x / resolution;
		texture.frame.y = packed.y / resolution;
		texture.frame.width = packed.width / resolution;
		texture.frame.height = packed.height / resolution;

		texture._updateUvs();

	} );

	document.body.appendChild( packer.canvas );

	var getPooled = function( pool, idx, texture ){
		var sprite;
		if( idx >= pool.length ){
			sprite = new PIXI.Sprite( texture );
			pool.push( sprite );
		}else{
			sprite = pool[idx];
			sprite.texture = texture;
		}

		return sprite;
	};

	var radians = 0;

	var rad360 = Math.PI * 2;
	var toRadians = Math.PI / 180;

	var render = function(){

		radians += toRadians * 4;

		for( var i = 0; i<arcSprites.length; i++ ){

			var lastIdx = -1;
			var entry = arcSprites[i];
			var pool = entry.pool;
			var rad = ( radians + entry.start ) % rad360;

			entry.arcs.drawRadians( rad , function( idx, radians, texture ){

				var sprite = getPooled( pool, idx, texture );
				if( !sprite.parent ) {
					entry.container.addChild( sprite );
				}
				sprite.rotation = radians;
				lastIdx = idx;
			});

			for( var j = lastIdx+1; j<pool.length; j++ ){
				if( pool[j].parent ){
					entry.container.removeChild( pool[j] );
				}
			}

		}


		renderer.render( stage );
		requestAnimationFrame( render );

	};

	render();

};
